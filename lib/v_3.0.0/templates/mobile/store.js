import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

import apiUtils from '../../global/utils/api';
import { convertListToMap, shouldFetch } from '../../global/utils/storeUtils';


// First define all API calls for __camelName__
/**
 * The functions below, called thunks, allow us to perform async logic. They
 * can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
 * will call the thunk with the `dispatch` function as the first argument. Async
 * code can then be executed and other actions can be dispatched. Thunks are
 * typically used to make async requests.
 * 
 * In practice we won't dispatch these directly, they will be dispatched by __camelName__Service which has a nicer api built on hooks.
 */

// CREATE
export const sendCreate__PascalName__ = createAsyncThunk(
  '__camelName__/sendCreate'
  , async (new__PascalName__) => {
    const endpoint = `/api/__kebabNamePlural__`;
    const response = await apiUtils.callAPI(endpoint, 'POST', new__PascalName__);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

// READ
export const fetchDefault__PascalName__ = createAsyncThunk(
  '__camelName__/fetchDefault'
  , async () => {
    const endpoint = `/api/__kebabNamePlural__/default`;
    const response = await apiUtils.callAPI(endpoint);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);
export const fetchSingle__PascalName__ = createAsyncThunk(
  '__camelName__/fetchSingle'
  , async (id) => {
    const endpoint = `/api/__kebabNamePlural__/${id}`;
    const response = await apiUtils.callAPI(endpoint);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);
export const fetch__PascalName__List = createAsyncThunk(
  '__camelName__/fetchList' // this is the action name that will show up in the console logger.
  , async (listArgs) => {
    const endpoint = `/api/__kebabNamePlural__?${listArgs}`;
    const response = await apiUtils.callAPI(endpoint);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

// UPDATE
export const sendUpdate__PascalName__ = createAsyncThunk(
  '__camelName__/sendUpdate'
  , async ({_id, ...updates}) => {
    const endpoint = `/api/__kebabNamePlural__/${_id}`;
    const response = await apiUtils.callAPI(endpoint, 'PUT', updates);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

// DELETE
export const sendDelete__PascalName__ = createAsyncThunk(
  '__camelName__/sendDelete'
  , async (id) => {
    const endpoint = `/api/__kebabNamePlural__/${id}`;
    const response = await apiUtils.callAPI(endpoint, 'DELETE');
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

// TODO: add sendDelete__PascalName__


// next define the store's initial state
const initialState = {
  /**
   * "byId" is an object map of all __camelName__ items in the store. The map's keys are
   * the Mongo ids of the objects by default. This is where all __camelName__ objects will live.
   */
  byId: {}
  
  /**
   * "queries" is an object map of all server fetches for __camelNamePlural__. The map's keys are listArgs
   * in the case of list fetches and Mongo ids in the case of single fetches.
   * Each individual query looks like this:
   * 
   * @example {
   *  expirationDate: date
   *  receivedAt: date
   *  status: 'pending' || 'fulfilled' || 'rejected'
   *  // for lists
   *  ids: [mongoId, mongoId]
   *  // for singles
   *  id: mongoId
   * }
   */
  , singleQueries: {}
  , listQueries: {}

};

// define the __camelName__Slice. This is a combination of actions and reducers. More info: https://redux-toolkit.js.org/api/createSlice
export const __camelName__Slice = createSlice({
  name: '__camelName__'
  , initialState
  /**
   * The `reducers` field lets us define reducers and generate associated actions.
   * Unlike the selectors defined at the bottom of this file, reducers only have access
   * to this specific reducer and not the entire store.
   * 
   * Again, we will not dispatch these directly, they will be dispatched by __camelName__Service.
   */
  , reducers: {
    invalidateQuery: (state, action) => {
      const queryKey = action.payload;
      const query = state.listQueries[queryKey] || state.singleQueries[queryKey];
      if(query) query.didInvalidate = true
    }
    , add__PascalName__ToList: (state, action) => {
      const { queryKey, id } = action.payload;
      const query = state.listQueries[queryKey];
      if(query) {
        query.ids.push(id)
      } else {
        console.log('Could not find list');
      }
    }
  }

  /**
   * The `extraReducers` field lets the slice handle actions defined elsewhere,
   * including actions generated by createAsyncThunk or in other slices.
   * We'll use them to track our server request status.
   * 
   * We'll add a case for each API call defined at the top of the file to dictate
   * what happens during each API call lifecycle.
   */
  , extraReducers: (builder) => {
    builder
      // CREATE
      .addCase(sendCreate__PascalName__.fulfilled, (state, action) => {
        // console.log('action', action);
        const __camelName__ = action.payload;
        // add it to the map
        state.byId[__camelName__._id] = __camelName__;
        // create a query object for it
        state.singleQueries[__camelName__._id] = {
          id: __camelName__._id
          , status: 'fulfilled'
          , receivedAt: Date.now()
          , expirationDate: Date.now() + (1000 * 60 * 5) // 5 minutes from now
        }

        // A new __camelName__ was just created. Rather than dealing with adding it to a list or invalidating specific lists from the component we'll just invalidate the listQueries here.
        Object.keys(state.listQueries).forEach(queryKey => {
          state.listQueries[queryKey].didInvalidate = true;
        });
      })
      .addCase(sendCreate__PascalName__.rejected, (state, action) => {
        // TODO: handle server errors
      })

      // READ
      .addCase(fetchDefault__PascalName__.pending, (state, action) => {
        // create a query object for it in the queries map. Instead of an id we'll use the string 'default__PascalName__'
        state.singleQueries['default__PascalName__'] = {
          id: 'default__PascalName__'
          , status: 'pending'
        };
      })
      .addCase(fetchDefault__PascalName__.fulfilled, (state, action) => {
        const default__PascalName__ = action.payload;
        // add it to the byId map (for the id we'll use 'default__PascalName__')
        state.byId['default__PascalName__'] = default__PascalName__
        // update the query object
        const singleQuery = state.singleQueries['default__PascalName__'];
        singleQuery.status = 'fulfilled';
        singleQuery.receivedAt = Date.now();
        singleQuery.expirationDate = Infinity; // this should never expire. It's just an empty __camelName__.
      })
      .addCase(fetchDefault__PascalName__.rejected, (state, action) => {
        const singleQuery = state.singleQueries['default__PascalName__'];
        singleQuery.status = 'rejected';
        singleQuery.receivedAt = Date.now();
      })
      .addCase(fetchSingle__PascalName__.pending, (state, action) => {
        // update or create a query object for it in the queries map
        state.singleQueries[action.meta.arg] = { ...state.singleQueries[action.meta.arg], id: action.meta.arg, status: 'pending', didInvalidate: false };
      })
      .addCase(fetchSingle__PascalName__.fulfilled, (state, action) => {
        const __camelName__ = action.payload;
        // add the __camelName__ object to the byId map
        state.byId[__camelName__._id] = __camelName__;
        // find the query object for this fetch in the singleQueries map and update query info
        const singleQuery = state.singleQueries[action.meta.arg];
        singleQuery.status = 'fulfilled';
        singleQuery.receivedAt = Date.now();
        singleQuery.expirationDate = Date.now() + (1000 * 60 * 5); // 5 minutes from now
      })
      .addCase(fetchSingle__PascalName__.rejected, (state, action) => {
        // find the query object for this fetch in the singleQueries map and update query info
        const singleQuery = state.singleQueries[action.meta.arg];
        singleQuery.status = 'rejected';
        singleQuery.receivedAt = Date.now();
      })
      .addCase(fetch__PascalName__List.pending, (state, action) => {
        // update or create the query object for it in the listQueries map
        state.listQueries[action.meta.arg] = { ...state.listQueries[action.meta.arg], status: 'pending', didInvalidate: false };
      })
      .addCase(fetch__PascalName__List.fulfilled, (state, action) => {
        const { __camelNamePlural__, totalPages } = action.payload;
        // update list query
        // convert the array of objects to a map
        const __camelName__Map = convertListToMap(__camelNamePlural__, '_id');
        // add the __camelName__ objects to the byId map
        state.byId = { ...state.byId, ...__camelName__Map };
        // find the query object for this fetch in the listQueries map and update query info
        const listQuery = state.listQueries[action.meta.arg];
        // save the array of ids for the returned __camelNamePlural__
        listQuery.ids = __camelNamePlural__.map(__camelName__ => __camelName__._id);
        // set the rest of the query info
        listQuery.totalPages = totalPages;
        listQuery.status = 'fulfilled';
        listQuery.receivedAt = Date.now();
        listQuery.expirationDate = Date.now() + (1000 * 60 * 5); // 5 minutes from now

        // while we're here we might as well add a single query for each of these since we know they're fresh
        __camelNamePlural__.forEach(__camelName__ => {
          // add a single query for the __camelName__.
          const singleQuery = {
            id: __camelName__._id
            , status: listQuery.status
            , receivedAt: listQuery.receivedAt
            , expirationDate: listQuery.expirationDate
          };
          state.singleQueries[__camelName__._id] = singleQuery;
        });
      })
      .addCase(fetch__PascalName__List.rejected, (state, action) => {
        // TODO: handle server errors
        const listQuery = state.listQueries[action.meta.arg];
        listQuery.status = 'rejected';
        listQuery.receivedAt = Date.now();
      })
      
      // UPDATE
      .addCase(sendUpdate__PascalName__.pending, (state, action) => {
        // action.meta.arg in this case is the updated __camelName__ object that was sent in the POST
        const updated__PascalName__ = action.meta.arg
        // get the __camelName__ id
        const id = updated__PascalName__._id;
        // access or create the query object in the map
        state.singleQueries[id] = { ...state.singleQueries[id], id: id, status: 'pending' }

        // optimistic update the version that's in the map
        state.byId[id] = { ...state.byId[id], ...updated__PascalName__}
      })
      .addCase(sendUpdate__PascalName__.fulfilled, (state, action) => {
        const __camelName__ = action.payload;
        // replace the previous version in the map with the new one from the server
        state.byId[__camelName__._id] = __camelName__;
        // update the query object
        const singleQuery = state.singleQueries[__camelName__._id];
        singleQuery.status = 'fulfilled';
        singleQuery.receivedAt = Date.now();
        singleQuery.expirationDate = Date.now() + (1000 * 60 * 5); // 5 minutes from now
      })
      .addCase(sendUpdate__PascalName__.rejected, (state, action) => {
        // action.meta.arg in this case is the updated __camelName__ object that was sent in the POST
        const __camelName__ = action.meta.arg
        // update the query object
        const singleQuery = state.singleQueries[__camelName__._id];
        singleQuery.status = 'rejected';
        singleQuery.receivedAt = Date.now();
      })
      .addCase(sendDelete__PascalName__.fulfilled, (state, action) => {
        const __camelName__Id = action.meta.arg;
        Object.keys(state.listQueries).forEach(queryKey => {
          // filter the __camelName__ from the existing lists before we remove it from the store below (avoid reference errors)
          state.listQueries[queryKey].ids = state.listQueries[queryKey].ids?.filter(id => id !== __camelName__Id);
          // invalidate existing lists
          state.listQueries[queryKey].didInvalidate = true;
        });
        // remove the query object
        delete state.singleQueries[__camelName__Id];
        // remove it from the map
        delete state.byId[__camelName__Id];
      })
      .addCase(sendDelete__PascalName__.rejected, (state, action) => {
        // TODO: handle errors
      })
  }
});

// export the actions defined above
export const { invalidateQuery, add__PascalName__ToList } = __camelName__Slice.actions;


// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.

export const fetchListIfNeeded = (queryKey) => (dispatch, getState) => {
  const __camelName__Query = getState().__camelName__.listQueries[queryKey];
  if(shouldFetch(__camelName__Query)) {
    // console.log('Fetching __camelName__ list', queryKey);
    dispatch(fetch__PascalName__List(queryKey));
  } else {
    // console.log('No need to fetch, fresh query in cache');
  }
};

export const fetchSingleIfNeeded = (id) => (dispatch, getState) => {
  const __camelName__Query = getState().__camelName__.singleQueries[id];
  if(shouldFetch(__camelName__Query)) {
    // console.log('Fetching __camelName__', id);
    if(id === 'default__PascalName__') {
      dispatch(fetchDefault__PascalName__());
    } else {
      dispatch(fetchSingle__PascalName__(id));
    }
  } else {
    // console.log('No need to fetch, fresh query in cache');
  }
}

/**
 * The functions below are called a selectors and allow us to select a value from
 * the store.
 * 
 * These are the replacement for the old mapStoreToProps functionality.
 * 
 * Selectors can also be defined inline where they're used instead of
 * in the slice file. For example: `useSelector((store) => store.__camelName__.value)`
 * 
 * Because selectors take the whole store as their first argument, and our
 * stores are all structured the same way, we could define these at the global
 * level and pass in the store we want to access when we use them.
 * 
 * for example in __camelName__Service:
 * 
 * const single__PascalName__ = useSelector(store => selectSingleById(store.__camelName__, __camelName__Id))
 * 
 * But to minimize the risk of over-generalizing, we'll define a set in each store.
 */


/**
 * 
 * @param {object} __camelName__Store - supplied by useSelector hook in the __camelName__Service file
 * @param {string} queryKey - the key used to access the query from the map
 * @returns an array of __camelName__ objects matching the query's `ids` array
 */
export const selectListItems = ({ __camelName__: __camelName__Store }, queryKey) => {
  const listIds = __camelName__Store.listQueries[queryKey]?.ids;
  if(listIds) {
    return listIds.map(id => __camelName__Store.byId[id]);
  } else {
    return null;
  }
}

export const selectListPageCount = ({ __camelName__: __camelName__Store }, listArgs) => {
  return __camelName__Store.listQueries[listArgs]?.totalPages;
}

export const selectSingleById = ({ __camelName__: __camelName__Store }, id) => {
  return __camelName__Store.byId[id];
}

export const selectQuery = ({ __camelName__: __camelName__Store }, queryKey) => {
  const __camelName__Query = __camelName__Store.listQueries[queryKey] || __camelName__Store.singleQueries[queryKey];
  return __camelName__Query || {};
}

export default __camelName__Slice.reducer;
